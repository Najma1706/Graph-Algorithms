A traveler needs to find the shortest path between every pair of cities in a road network. The cities are connected by roads, each with a specific travel cost. To do this, the traveler uses the Floyd-Warshall Algorithm to calculate the shortest distances between every pair of cities in a given edge-weighted undirected graph.

Example1 

Input:

4

3

0 1 2

1 2 3

2 3 4

Output:

Original matrix

0 2 INF INF 

2 0 3 INF 

INF 3 0 4 

INF INF 4 0 

Shortest path matrix

0 2 5 9 

2 0 3 7 

5 3 0 4 

9 7 4 0



Explanation: 

Given: 4 nodes (0, 1, 2, 3) and 3 edges: 0 → 1 (weight 2), 1 → 2 (weight 3), 2 → 3 (weight 4)

Any node pair without a direct edge is considered INF (unreachable initially).

Step 1: Construct Initial Graph (Original Matrix)

0   2   INF INF

2   0   3   INF

INF 3   0   4

INF INF 4   0

Diagonal elements (self to self) are 0.
If no direct path exists, it's INF.
Step 2: Running Floyd-Warshall Algorithm

Using node 0 as an intermediate: No updates since it only connects to node 1.

Using node 1 as an intermediate: 0 → 2 via 1: 0 → 1 (2) + 1 → 2 (3) = 5 

													  2 → 0 also updates to 5.

Using node 2 as an intermediate: 0 → 3 via 2: 0 → 2 (5) + 2 → 3 (4) = 9

													  1 → 3 via 2: 1 → 2 (3) + 2 → 3 (4) = 7

Using node 3 as an intermediate: No further updates.

Step 3: Final Shortest Path Matrix

0 2 5 9 

2 0 3 7 

5 3 0 4 

9 7 4 0

Input format :
The first line contains an integer V representing the number of cities (vertices) in the network.

The second line contains an integer E representing the number of roads (edges) in the network.

The next E lines each contain three space-separated integers u, v, w, where u and v represent the cities connected by a road, and w represents the travel cost (weight) of the road.

Output format :
The first line of output prints the original matrix, where each entry represents the direct travel cost between two cities. If there is no direct road between two cities, represent the cost as INF.

Then, print the shortest path matrix, where each entry represents the shortest travel cost between every pair of cities, computed using the Floyd-Warshall algorithm.



Refer to the sample output for formatting specifications.

Code constraints :
The given test cases fall under the following specifications:

1 ≤ V ≤ 1000

0 ≤ E ≤ 10,000

0 ≤ u, v < V

-1000 ≤ w ≤ 1000

Sample test cases :
Input 1 :
4
3
0 1 2
1 2 3
2 3 4
Output 1 :
Original matrix
0 2 INF INF 
2 0 3 INF 
INF 3 0 4 
INF INF 4 0 

Shortest path matrix
0 2 5 9 
2 0 3 7 
5 3 0 4 
9 7 4 0 
Input 2 :
5
5
0 1 2
0 2 7
1 2 3
2 3 4
3 4 5
Output 2 :
Original matrix
0 2 7 INF INF 
2 0 3 INF INF 
7 3 0 4 INF 
INF INF 4 0 5 
INF INF INF 5 0 

Shortest path matrix
0 2 5 9 14 
2 0 3 7 12 
5 3 0 4 9 
9 7 4 0 5 
14 12 9 5 0 


#include <bits/stdc++.h>
using namespace std;
int main() {
    int v,e;
    cin>>v>>e;
    int INF=INT_MAX;
    vector<vector<int>>graph(v,vector<int>(v,INF));
    for(int i=0; i<v; i++) graph[i][i]=0;
    for(int i=0; i<e; i++) {
        
        int u,v,w;
        cin>>u>>v>>w;
        graph[u][v]=w;
        graph[v][u]=w;
    }
    cout<<"Original matrix"<<endl;
    for(int i=0; i<v; i++) {
        for(int j=0; j<v; j++) {
            if(graph[i][j]==INF) cout<<"INF ";
            else cout<<graph[i][j]<<" ";
        }
        cout<<endl;
    }
    
    cout<<endl<<"Shortest path matrix"<<endl;
    for(int k=0; k<v; k++) {
        for(int i=0; i<v; i++) {
            for(int j=0; j<v; j++) {
                if(graph[i][k]!=INF && graph[k][j]!=INF){
                    graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);
                }
            }
        }
    }
    for(int i=0; i<v; i++) {
        for(int j=0; j<v; j++) {
            cout<<graph[i][j]<<" ";
        }
        cout<<endl;
    }
}
